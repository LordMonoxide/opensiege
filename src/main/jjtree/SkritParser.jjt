options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;

  // jjtree
  MULTI = true;
}

PARSER_BEGIN(SkritParser)

package lofimodding.opensiege;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class SkritParser {
  public static void main(final String[] args) throws ParseException, IOException {
    final Path path = Path.of("C:/Users/corey/OneDrive/Desktop/DS Hacking/Raw Files/world/global/skrits/weapon_cold.skrit");
    SkritParser parser = new SkritParser(Files.newInputStream(path));

    try {
      Node n = parser.CompilationUnit();
      n.dump("");
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}

PARSER_END(SkritParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < BOOL: "bool" >
| < DOC: "doc" >
| < ELSE: "else" >
| < FALSE: "false" >
| < FLOAT: "float" >
| < IF: "if" >
| < INT: "int" >
| < PROPERTY: "property" >
| < RETURN: "return" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
      <DECIMAL_LITERAL>
    | <HEX_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
    | "." (["0"-"9"])+ (<EXPONENT>)?
    | (["0"-"9"])+ <EXPONENT>
    | (["0"-"9"])+ (<EXPONENT>)?
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
    "\""
    (
        (~["\"","\\","\n","\r"])
      | ("\\"
        (
            ["n","t","b","r","f","\\","'","\""]
          | ["0"-"7"] ( ["0"-"7"] )?
          | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        )
      )
    )*
    "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
    [  // all chars that can start an identifier
      "$",
      "A"-"Z",
      "_",
      "a"-"z"
    ]
  >
|
  < #PART_LETTER:
    [  // all chars that can be part of an identifier
      "$",
      "0"-"9",
      "A"-"Z",
      "_",
      "a"-"z"
    ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < EQISH: "~=" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < LTGT: "<>" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < POW: "**" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < POWASSIGN: "**=" >
}

/** Root production. */
Node CompilationUnit() #Start :
{}
{
  ( BodyDeclaration() )+ <EOF>
  { return jjtThis; }
}

void BodyDeclaration() #void :
{}
{
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
| PropertyDelcaration()
| FieldDeclaration()
}

void FieldDeclaration() :
{}
{
  Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"
}

void PropertyDelcaration() :
{}
{
  <PROPERTY> Type() VariableDeclarator() <DOC> <ASSIGN> <STRING_LITERAL> ";"
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{}
{
  LOOKAHEAD(2)
  <IDENTIFIER> ( "(" | "{" )
| ( LOOKAHEAD(2) ResultType() )? <IDENTIFIER> ( "(" | "{" )
}

void MethodDeclaration() :
{}
{
  LOOKAHEAD(2)
  MethodDeclarator() Block()
| ( LOOKAHEAD(2) ResultType() )? MethodDeclarator() Block()
}

void Block() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement() :
{}
{
  LOOKAHEAD(Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
| Statement()
}

void LocalVariableDeclaration() :
{}
{
  Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void MethodDeclarator() :
{}
{
  <IDENTIFIER> ( FormalParameters() )?
}

void FormalParameters() :
{}
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter() :
{}
{
  Type() ( VariableDeclaratorId() )?
}

// VARIABLES =========================================

void VariableDeclarator() :
{}
{
  VariableDeclaratorId() [ <ASSIGN> VariableInitializer() ]
}

void VariableDeclaratorId() :
{}
{
  <IDENTIFIER>
}

void VariableInitializer() :
{}
{
  Expression()
}

void Name() :
{}
{
  <IDENTIFIER> ( LOOKAHEAD(2) "." <IDENTIFIER> )*
}

void Expression() #void :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{}
{
  ConditionalExpression() [ AssignmentOperator() Expression() ]
}

void AssignmentOperator() :
{}
{
  <ASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <REMASSIGN> | <PLUSASSIGN> | <MINUSASSIGN> | <ANDASSIGN> | <XORASSIGN> | <ORASSIGN>
}

void ConditionalExpression() #void :
{}
{
  ( ConditionalOrExpression() [ <HOOK> Expression() <COLON> ConditionalExpression() ] ) #Tern(>1)
}

void ConditionalOrExpression() #void :
{}
{
  ( ConditionalAndExpression() ( <SC_OR> ConditionalAndExpression() )* ) #Or(>1)
}

void ConditionalAndExpression() #void :
{}
{
  ( InclusiveOrExpression() ( <SC_AND> InclusiveOrExpression() )* ) #And(>1)
}

void InclusiveOrExpression() #void :
{}
{
  ( ExclusiveOrExpression() ( LOOKAHEAD(2) <ORASSIGN> ExclusiveOrExpression() )* ) #BitOr(>1)
}

void ExclusiveOrExpression() #void :
{}
{
  ( AndExpression() ( LOOKAHEAD(2) <XORASSIGN> AndExpression() )* ) #BitXor(>1)
}

void AndExpression() #void :
{}
{
  ( EqualityExpression() ( LOOKAHEAD(2) <ANDASSIGN> EqualityExpression() )* ) #BitAnd(>1)
}

void EqualityExpression() #void :
{}
{
  ( RelationalExpression() ( ( LOOKAHEAD(2) <EQ> | <NE> | <LTGT> ) RelationalExpression() )* ) #Equality(>1)
}

void RelationalExpression() #void :
{}
{
  ( AdditiveExpression() ( ( LOOKAHEAD(2) <LT> | <GT> | <LE> | <GE> ) AdditiveExpression() )* ) #Relative(>1)
}

void AdditiveExpression() #void :
{}
{
  ( MultiplicativeExpression() ( ( LOOKAHEAD(2) <PLUS> | <MINUS> ) MultiplicativeExpression() )* ) #Add(>1)
}

void MultiplicativeExpression() #void :
{}
{
  ( PowerExpression() ( ( LOOKAHEAD(2) <STAR> | <SLASH> | <REM> ) PowerExpression() )* ) #Mult(>1)
}

void PowerExpression() #void :
{}
{
  ( UnaryExpression() ( <POW> UnaryExpression() )* ) #Pow(>1)
}

void UnaryExpression() #void :
{}
{
  (
    ( <PLUS> | <MINUS> ) UnaryExpression()
  | PrimaryExpression()
  | UnaryExpressionNotPlusMinus()
  ) #Unary(>1)
}

void UnaryExpressionNotPlusMinus() #void :
{}
{
  (
    <BANG> UnaryExpression()
  | PrimaryExpression()
  ) #Unary2(>1)
}

void PrimaryExpression() :
{}
{
  PrimaryPrefix() ( PrimarySuffix() )*
}

void PrimaryPrefix() :
{}
{
  Literal()
| "(" Expression() ")"
| Name()
}

void PrimarySuffix() :
{}
{
   "." <IDENTIFIER>
| Arguments()
}

void Literal() :
{}
{
  <INTEGER_LITERAL>
| <FLOATING_POINT_LITERAL>
| <STRING_LITERAL>
| BooleanLiteral()
}

void BooleanLiteral() :
{}
{
  <TRUE> | <FALSE>
}

void Arguments() :
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}

void Type() :
{
  ASTPrimitiveType primitive;
  Token t;
}
{
  primitive = PrimitiveType() { jjtThis.jjtSetValue(primitive.value); }
| t = <IDENTIFIER> { jjtThis.jjtSetValue(t.image); }
}

ASTPrimitiveType PrimitiveType() :
{
  Token t;
}
{
  t = <BOOL> { jjtThis.jjtSetValue(t.image); return jjtThis; }
| t = <INT> { jjtThis.jjtSetValue(t.image); return jjtThis; }
| t = <FLOAT> { jjtThis.jjtSetValue(t.image); return jjtThis; }
}

void ResultType() :
{}
{
  <VOID> | Type()
}

// STATEMENTS ===============================================

void Statement() :
{}
{
  LOOKAHEAD(2)
  Block()
| StatementExpression() ";"
| IfStatement()
//| WhileStatement()
//| DoStatement()
//| BreakStatement()
//| ContinueStatement()
| ReturnStatement()
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{}
{
  PrimaryExpression() [ AssignmentOperator() Expression() ]
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(1) <ELSE> Statement() ]
}

void ReturnStatement() :
{}
{
  <RETURN> [ Expression() ] ";"
}
